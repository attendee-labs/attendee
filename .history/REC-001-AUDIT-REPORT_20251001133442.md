# REC-001: Audit and Documentation Report

## Executive Summary

This document provides a comprehensive audit of the custom features in our forked transcript-meeting-recorder service that need to be re-implemented when migrating to the upstream attendee project. The analysis reveals several key divergences from the upstream project that must be carefully ported to maintain functionality.

## Current Custom Implementation Analysis

### 1. OpenStack Swift Storage Backend

**Location**: `bots/storage/`
**Files**: 
- `infomaniak_storage.py` - Django storage backend
- `infomaniak_swift_utils.py` - Utility functions

**Current Implementation**:
- Custom Django storage class `InfomaniakSwiftStorage` implementing the Django Storage interface
- Uses OpenStack Swift client with application credential authentication
- Supports basic operations: save, open, delete, exists, listdir, size, url generation
- Configuration via environment variables:
  - `OS_AUTH_URL`
  - `OS_APPLICATION_CREDENTIAL_ID` 
  - `OS_APPLICATION_CREDENTIAL_SECRET`
  - `OS_REGION_NAME`
  - `SWIFT_CONTAINER_MEETS` (default: "transcript-meets")

**Key Functions**:
- `upload_file_to_swift()` - Upload file content or file path
- `delete_file_from_swift()` - Remove objects
- `generate_presigned_url()` - Generate access URLs
- `download_file_from_swift()` - Download file content

**Migration Requirements**:
- The upstream project has external storage support via `external_media_storage_settings`
- Upstream supports S3-compatible storage through `ExternalMediaStorageSettingsJSONField`
- Need to implement Swift-compatible bridge or convince upstream to add Swift support
- Current implementation could be contributed back to upstream

### 2. Custom File Naming via file_name Parameter

**Location**: `bots/bots_api_views.py`, `bots/serializers.py`
**Current Implementation**:
- Custom `RecordingCreateView` endpoint accepts `file_name` parameter
- `CreateBotSerializer` includes `file_name` field
- Recording model stores `file_name` in database
- Bot controller uses `get_recording_filename()` method that prioritizes `file_name` over generated names

**Upstream Alternative**:
- Upstream supports `metadata` field in `CreateBotSerializer`
- Upstream has `external_media_storage_settings.recording_file_name` for custom naming
- Bot model includes `metadata` JSONField

**Migration Path**:
- Replace custom `file_name` parameter with upstream `metadata` field
- Use upstream `external_media_storage_settings.recording_file_name` for storage naming
- Update Gateway integration to pass file names via metadata or recording_file_name

### 3. Transcription Service Integration

**Location**: `transcript_services/v1/api_service.py`
**Current Implementation**:
- `start_transcription(transcript_uuid)` - Calls `/v1/record/done` endpoint
- `could_not_record(transcript_id)` - Calls `/v1/record/failed` endpoint
- Called from `bot_controller.py` after successful file upload
- Uses transcript ID extracted from filename

**Integration Points**:
- Called in `bot_controller.py` after file upload completion
- Triggered on upload success or failure
- Requires custom logic to extract transcript ID from filename

**Upstream Alternative**:
- Upstream has webhook system via `WebhookSubscription` model
- Supports webhook triggers for various bot events
- Has built-in callback mechanisms

**Migration Requirements**:
- Implement webhook-based approach instead of direct API calls
- Configure webhook endpoints to receive bot completion events
- Update Gateway to handle webhook notifications instead of direct calls

### 4. Custom Helm Charts and Deployment

**Location**: `charts/transcript-meeting-recorder/`
**Current Configuration**:
- Custom chart name: `transcript-meeting-recorder-api`
- Specific image repository: `vanyabrucker/transcript-meeting-recorder`
- Environment variables for Kubernetes bot launching
- HPA configuration for auto-scaling
- Custom resource limits and requests

**Key Settings**:
```yaml
env:
  LAUNCH_BOT_METHOD: "kubernetes"
  K8S_CONFIG: transcript-config
  K8S_SECRETS: transcript-secrets
  BOT_POD_IMAGE: vanyabrucker/transcript-meeting-recorder
```

**Migration Requirements**:
- Update chart to use upstream image and configurations
- Ensure environment variables align with upstream requirements
- Test Kubernetes bot pod creation with new service

### 5. Database Schema Differences

**Current Custom Fields**:
- `Recording.file_name` - Custom field for storing filename
- Various configuration differences in settings

**Upstream Schema**:
- `Bot.metadata` - JSONField for arbitrary metadata
- `external_media_storage_settings` in bot settings
- Webhook-based event system

## Upstream Project Capabilities Analysis

### Available Features That Replace Custom Logic

1. **Metadata Support**:
   - `Bot.metadata` JSONField supports arbitrary data
   - Can store filename, client_id, or any custom information
   - Available in API via `metadata` parameter

2. **External Storage Support**:
   - `external_media_storage_settings` configuration
   - Support for custom bucket names and file names
   - `recording_file_name` field for custom naming
   - S3-compatible storage backend support

3. **Webhook System**:
   - `WebhookSubscription` model for event notifications
   - Multiple trigger types supported
   - Can replace direct API callback approach

4. **Kubernetes Pod Management**:
   - Built-in support for Kubernetes bot deployment
   - Environment variable configuration
   - Pod creation and management

## Migration Strategy and Implementation Plan

### Phase 1: Core Service Migration
1. **Set up fresh upstream clone**
2. **Implement Swift storage adapter**:
   - Create Swift-compatible storage class that works with upstream's external storage interface
   - Map Swift authentication to upstream credential system
3. **Update API integration**:
   - Replace `file_name` parameter with `metadata` field containing filename
   - Use `external_media_storage_settings.recording_file_name` for custom naming

### Phase 2: Integration Updates
1. **Gateway Integration**:
   - Update Gateway to use `metadata` field instead of `file_name`
   - Configure external storage settings in bot creation requests
2. **Webhook Implementation**:
   - Replace direct transcript service calls with webhook system
   - Configure webhook endpoints in Gateway
   - Update transcript service to handle webhook notifications

### Phase 3: Deployment Migration
1. **Helm Chart Updates**:
   - Adapt charts to use upstream image and configurations
   - Update environment variables for upstream compatibility
2. **Testing and Validation**:
   - Test complete flow in staging environment
   - Validate file uploads to Swift storage
   - Confirm webhook delivery to transcript services

## Risk Assessment

### High Risk Items
1. **Swift Storage Compatibility**: Upstream may not support Swift out of the box
2. **Webhook Reliability**: Ensuring webhook delivery vs direct API calls
3. **Filename Handling**: Complex logic around transcript ID extraction

### Medium Risk Items
1. **Environment Variable Changes**: Configuration drift during migration
2. **Kubernetes Configuration**: Pod creation and resource management
3. **Database Migration**: Ensuring data compatibility

### Low Risk Items
1. **Metadata Migration**: Straightforward field mapping
2. **Helm Chart Updates**: Standard configuration changes

## Recommendations

1. **Contribute Swift Support Upstream**: Consider contributing Swift storage backend to attendee project
2. **Incremental Migration**: Implement changes in phases with rollback capability
3. **Enhanced Testing**: Comprehensive integration testing in staging environment
4. **Documentation**: Detailed runbooks for configuration and deployment

## Estimated Complexity Scores

- **REC-002 (Swift Storage)**: 4/5 - Complex due to potential upstream limitations
- **REC-003 (Metadata Usage)**: 1/5 - Simple field mapping
- **REC-004 (Webhook Integration)**: 2/5 - Moderate complexity for reliable delivery
- **REC-005 (Helm Charts)**: 4/5 - Complex due to configuration and testing requirements

## Conclusion

The migration is feasible with upstream providing most required functionality through metadata and external storage features. The primary challenges lie in Swift storage integration and reliable webhook delivery for transcript service integration. A phased approach with proper testing will minimize risks during the transition.